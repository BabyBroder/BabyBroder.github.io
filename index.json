[{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/","section":"Doan Duc Anh","summary":"","title":"Doan Duc Anh","type":"page"},{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/tags/exploitation/","section":"Tags","summary":"","title":"Exploitation","type":"tags"},{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/tags/operating-systems/","section":"Tags","summary":"","title":"Operating Systems","type":"tags"},{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Introduction # Race conditions are a common yet critical issue in both digital systems and cybersecurity, where improper handling of simultaneous operations can cause unpredictable behavior. Whether in logic circuits or software applications, race conditions can lead to unexpected glitches, security vulnerabilities, and even full system compromises.\nRace Conditions in Reality # Imagine two people trying to withdraw money from the same bank account at the exact same time. If the system doesn\u0026rsquo;t handle both requests properly, it might allow them to overdraw the account — resulting in unexpected or incorrect behavior. This scenario perfectly illustrates the essence of a race condition: when the outcome depends on the timing of events.\nIn the world of cybersecurity, race conditions have been at the heart of some of the most infamous vulnerabilities, such as the Dirty COW exploit (CVE-2016-5195). These types of bugs allow attackers to manipulate a system by taking advantage of timing issues in how resources are accessed.\nWhy Should You Care? # Race conditions aren\u0026rsquo;t just an abstract concept in digital circuits or operating systems — they are a real-world problem that attackers can exploit to:\nBypass security controls Gain unauthorized access Corrupt or modify data Understanding how race conditions occur, both in hardware and software, is essential for anyone working in system design, security analysis, or exploit development.\nWhat is a Race Condition? # A race condition happens when two or more entities simultaneously access, modify, or interact with a shared resource. The outcome depends on the order and timing of these interactions. Because the entities operate independently, their actions can overlap, leading to unexpected results or conflicts. This unpredictability can disrupt processes that rely on consistent or coordinated use of the shared resource.\nRace Condition in Logic Circuits # The race condition was first observed in logic circuits, where differences in propagation delays between circuit components can cause unintended glitches or incorrect outputs.\nA race condition in a logic circuit occurs when the output depends on the timing of input signal changes, leading to unintended behavior or glitches. This happens due to differences in propagation delays of the logic gates involved.\nThe term race condition was already in use by 1954, for example in David A. Huffman\u0026rsquo;s doctoral thesis \u0026ldquo;The synthesis of sequential switching circuits\u0026rdquo;.\nThe circuit has one input signal: A. It consists of: A NOT gate with a propagation delay of Δt₁. An AND gate with a propagation delay of Δt₂. Propagation delay refers to the time it takes for a signal to travel through a logic gate from input to output.\nNOT gate delay (Δt₁):\nWhen the input A is fed into the NOT gate, it takes Δt₁ units of time for the NOT gate to produce the correct output.\nAND gate delay (Δt₂):\nWhen the input signals arrive at the AND gate, it takes Δt₂ units of time for the gate to produce the correct output.\nLet\u0026rsquo;s assume the input A changes from low (0) to high (1). The race condition occurs due to the following timing differences:\nThe NOT gate inverts the input A with a propagation delay of Δt₁. The AND gate then combines the original input A with the inverted value A\u0026rsquo; from the NOT gate. However, due to the delay in the NOT gate, A\u0026rsquo; reaches the AND gate later than A, creating a timing mismatch. The AND gate also introduces its own delay of Δt₂, further contributing to the glitch that causes the race condition. When the input A changes from 0 to 1:\nThe AND gate receives the original input A immediately. The NOT gate takes Δt₁ time to update its output. The AND gate will output a short spike because it initially receives the old value from the NOT gate before the NOT gate\u0026rsquo;s output stabilizes. The duration of this spike is:\n(Δt₁ + Δt₂) - Δt₂ = Δt₁ Note\nThe sum of Δt₁ and Δt₂ represents the critical path — the longest path that a signal must travel through the circuit, determining the circuit\u0026rsquo;s overall delay. Race Condition in Software # When I research Race Conditon, I wonder why race conditions in software are often detected later than hardware race conditions, even though both deal with concurrency issues.\nThere are a few primary keys involved\nTiming Sensitivity: Hardware Requires Precise Timing Detection.\nIn hardware, timing is critical because circuits rely on exact timing of signals to function correctly. Even a tiny delay in signal propagation can cause a critical failure, such as setup/hold time violations or metastability in flip-flops. Since hardware is physically built and operates in real-time, race conditions must be detected early during the circuit design phase. If a race condition in hardware goes undetected, it can cause permanent physical failures in chips, making the hardware unusable → Hardware race condition detection happens early because it\u0026rsquo;s mission-critical to ensure circuits work reliably before they are manufactured.\nSoftware Race Conditions Depend on Runtime Behavior.\nIn contrast, software race conditions are logical bugs that emerge based on runtime behavior, meaning they depend on how the program runs in a particular environment. Concurrency isn\u0026rsquo;t always deterministic: Software race conditions depend on the operating system\u0026rsquo;s thread scheduling and hardware execution timing, which vary across different runs. They don\u0026rsquo;t always manifest: Some race conditions might only occur under specific conditions (e.g., heavy system load or specific input sequences), making them hard to detect during development. Testing tools aren\u0026rsquo;t perfect: Detecting software race conditions requires tools like ThreadSanitizer, Valgrind, or dynamic analysis tools, but these tools can slow down the program significantly, making it impractical to use them all the time. → Software race conditions may only be discovered later during testing or even after deployment, when they manifest in real-world use cases.\nRace Conditions # A race condition occurs in software when multiple code paths are executed concurrently, and the outcome depends on the timing of these operations. If the execution times of these paths vary unexpectedly, they may complete in an unintended order, leading to unanticipated behavior and software bugs. In some cases, race conditions can also arise between two or more separate programs, potentially resulting in security vulnerabilities.\nHow Race Conditions Happen # Race conditions typically occur in scenarios involving concurrent processes or multithreading. For example, when two threads attempt to access shared resources (such as files, memory, or hardware) simultaneously, without proper synchronization mechanisms, one thread might override or conflict with the other. This can lead to inconsistent data, crashes, or even security breaches.\nSecurity Risks # Race conditions pose significant security risks, as attackers can exploit these timing issues to manipulate a program\u0026rsquo;s execution. Some common attack vectors include:\nPrivilege Escalation: Exploiting timing vulnerabilities to gain unauthorized access or escalate user privileges. Data Corruption: Modifying or deleting critical data by manipulating the execution order of operations. Denial of Service (DoS): Triggering unexpected behaviors that cause the system to crash or hang, disrupting normal operation. Practical Example # Producer-Consumer # Problem # This code demonstrates a race condition between two threads: a producer and a consumer. Both threads share a common resource, products, which is a variable that tracks the total number of produced and consumed products. The producer thread increments the products variable, and the consumer thread decrements it. Without proper synchronization, this code exhibits undefined behavior, leading to potential issues such as negative values for products.\nint products = 0; void *producer(void *arg) { while (products \u0026lt; 100) { products++; printf(\u0026#34;+------------------+\\n\u0026#34;); printf(\u0026#34;|Produced a product|\\tTotal products: %d\\n\u0026#34;, products); } return NULL; } void *consumer(void *arg) { while (products \u0026gt; 0) { products--; printf(\u0026#34;+------------------+\\n\u0026#34;); printf(\u0026#34;|Consumed a product|\\tTotal products: %d\\n\u0026#34;, products); } return NULL; } The main issue lies in the concurrent access to the shared resource products by both threads. Since the increment (products++) and decrement (products--) operations are not atomic, the threads can interfere with each other, causing incorrect results.\nFor example:\nThe producer thread reads the value of products. The consumer thread also reads the value of products (which has not been updated by the producer yet). Both threads perform their operations (increment and decrement), leading to an incorrect final value of products, which can become a false update. In this code, I visualize the process of producing and consuming a product, where products is the shared variable of both threads. When I run this code, the value of products might be a false update.\nOne output sample Solution # To fix the race condition, we use mutexes to synchronize access to the shared resource. This ensures that only one thread at a time can access and modify the products variable, making the program\u0026rsquo;s behavior predictable and correct.\nKey Changes # Mutex Locking: We use pthread_mutex_lock before accessing products to ensure mutual exclusion, preventing both threads from modifying the variable simultaneously. Mutex Unlocking: After a thread has finished modifying the variable, it releases the lock with pthread_mutex_unlock, allowing the other thread to access the shared resource. code\nvoid *producer(void *arg) { while (products \u0026lt; 100) { pthread_mutex_lock(\u0026amp;lock); products++; printf(\u0026#34;+------------------+\\n\u0026#34;); printf(\u0026#34;|Produced a product|\\tTotal products: %d\\n\u0026#34;, products); pthread_mutex_unlock(\u0026amp;lock); } return NULL; } void *consumer(void *arg) { while (products \u0026gt; 0) { pthread_mutex_lock(\u0026amp;lock); products--; printf(\u0026#34;+------------------+\\n\u0026#34;); printf(\u0026#34;|Consumed a product|\\tTotal products: %d\\n\u0026#34;, products); pthread_mutex_unlock(\u0026amp;lock); } return NULL; } Bank account # Note\nIn a multi-threaded program, the operating system\u0026rsquo;s scheduler decides when to switch between threads (called a context switch). However, context switches don\u0026rsquo;t always happen exactly where we want during testing, making it hard to reproduce race conditions.\nBy inserting a small delay using usleep(1). This increase the likelihood that the operating system will perform a context switch at that point and Force both threads to access shared resources at overlapping times, increasing the chances of a race condition.\nProblem # Without the delay, the program might run so fast that both operations complete before a context switch happens, making the race condition harder to observe.\nIn this code, two threads perform deposit and withdrawal operations on a shared bank account balance. Due to the lack of proper synchronization, a race condition occurs, causing incorrect balance updates.\nint balance = 1000; int depositAmount = 500; int withdrawAmount = 300; void* deposit(void* arg) { int amount = *(int*)arg; int temp = balance; usleep(1); balance = temp + amount; printf(\u0026#34;Deposit: +%d, New Balance: %d\\n\u0026#34;, amount, balance); return NULL; } void* withdraw(void* arg) { int amount = *(int*)arg; if (balance \u0026gt;= amount) { int temp = balance; usleep(1); balance = temp - amount; printf(\u0026#34;Withdraw: -%d, New Balance: %d\\n\u0026#34;, amount, balance); } else { printf(\u0026#34;Withdraw: -%d, Insufficient funds! Current Balance: %d\\n\u0026#34;, amount, balance); } return NULL; } The race condition occurs because two threads simultaneously access and update a shared bank account balance without synchronization. In this example, the deposit thread reads the balance as 1000 and calculates a new balance of 1500 after adding 500. Meanwhile, the withdrawal thread also reads the balance as 1000 and calculates a new balance of 700 after subtracting 300. Since both threads perform their operations based on the initial balance of 1000, the withdrawal thread overwrites the deposit result. This leads to an incorrect final balance of 700 instead of the expected 1200, demonstrating how concurrent access to shared data can cause inconsistent results.\nThe root cause of the issue is that both threads read outdated values of the shared balance variable before any updates occur. As a result, each thread performs calculations using incorrect data and then writes its result, overwriting the other thread\u0026rsquo;s update.\nFor example:\nThe deposit thread reads the balance as 1000. The withdrawal thread also reads the balance as 1000, before the deposit thread has updated it. The deposit thread calculates the new balance as 1500 (by adding 500) and updates the balance. The withdrawal thread calculates the new balance as 700 (by subtracting 300) and overwrites the deposit thread’s result. In this code, the shared variable balance is accessed and modified by both threads without synchronization, causing a race condition. When I run this code, the final balance may be incorrect due to simultaneous operations, as the withdrawal thread can overwrite the deposit thread’s update.\nOne output sample Solution # To fix the race condition in the bank account example, we use mutexes to synchronize access to the shared balance variable. This ensures that only one thread at a time can read or update the balance, preventing inconsistent results caused by simultaneous operations. By locking the critical section where the balance is accessed, the program\u0026rsquo;s behavior becomes predictable and correct.\nKey Changes # Mutex Locking: We use pthread_mutex_lock before reading or modifying the balance variable to ensure mutual exclusion, preventing both the deposit and withdrawal threads from accessing the variable at the same time. Mutex Unlocking: After a thread completes its operation on the balance variable, it releases the lock using pthread_mutex_unlock, allowing the other thread to safely access the shared resource. Critical Section: The balance update logic is enclosed within the locked section to ensure that all read-modify-write operations are atomic and cannot be interrupted by another thread. pthread_mutex_t lock; int balance = 1000; int depositAmount = 500; int withdrawAmount = 300; void *deposit(void *arg) { int amount = *(int *)arg; pthread_mutex_lock(\u0026amp;lock); int temp = balance; usleep(1); balance = temp + amount; printf(\u0026#34;Deposit: +%d, New Balance: %d\\n\u0026#34;, amount, balance); pthread_mutex_unlock(\u0026amp;lock); return NULL; } void *withdraw(void *arg) { int amount = *(int *)arg; pthread_mutex_lock(\u0026amp;lock); if (balance \u0026gt;= amount) { int temp = balance; usleep(1); balance = temp - amount; printf(\u0026#34;Withdraw: -%d, New Balance: %d\\n\u0026#34;, amount, balance); } else { printf(\u0026#34;Withdraw: -%d, Insufficient funds! Current Balance: %d\\n\u0026#34;, amount, balance); } pthread_mutex_unlock(\u0026amp;lock); return NULL; } code\nRace Conditions in Operating Systems # Race conditions in operating systems occur when multiple processes or threads compete to access shared resources without proper synchronization. These issues can lead to unexpected behaviors, system crashes, data corruption, and security vulnerabilities. Understanding race conditions is critical for operating system developers, cybersecurity professionals, and CTF participants who explore kernel-level challenges.\nCommon Scenarios # File Access: Multiple processes accessing the same file simultaneously. Resource Allocation: Competing processes attempting to acquire system resources (e.g., memory, I/O devices). Inter-process Communication (IPC): Race conditions in pipes, message queues, or shared memory. Real-World # Race conditions can have severe consequences, affecting system stability, security, and functionality. Here are some notable real-world examples:\nData Corruption: A race condition in a database system could corrupt critical data, leading to incorrect application behavior. System Crashes: Operating systems can crash if kernel-level race conditions corrupt essential structures. Security Breaches: Attackers can exploit race conditions to escalate privileges, bypass security checks, or inject malicious code. Notable CVEs Related to Race Conditions # Race conditions are a common source of vulnerabilities in operating systems. Here are some notable CVEs:\nCVE-2016-5195 (Dirty COW)\nDescription: A race condition in the Linux kernel\u0026rsquo;s memory subsystem allowed attackers to gain write access to read-only files, leading to privilege escalation. Impact: This vulnerability was widely exploited, affecting millions of Linux systems. Fix: The issue was patched by implementing proper synchronization in the kernel\u0026rsquo;s memory management. CVE-2021-3493\nDescription: A race condition in the overlay filesystem in the Linux kernel allowed attackers to gain root privileges. Impact: Exploited in the wild to gain unauthorized access. Fix: The patch involved fixing the synchronization issue in the filesystem. CVE-2014-4014\nDescription: A race condition in the handling of user credentials in FreeBSD allowed attackers to hijack sessions. Impact: This vulnerability compromised the confidentiality and integrity of user sessions. Fix: Proper locking mechanisms were introduced to address the race condition. \u0026hellip;\nRace conditions often appear in Capture the Flag (CTF) challenges, particularly in the pwnable category, where participants exploit kernel vulnerabilities to achieve privilege escalation.\nMitigation Techniques # Use Proper Synchronization Primitives:\nMutexes Semaphores Spinlocks Minimize Critical Sections:\nReduce the amount of code executed within critical sections to minimize contention. Implement Atomic Operations:\nUse atomic operations for shared resource access to ensure data consistency. Conclusion # Race conditions are a critical issue in multi-threaded and multi-process systems, where the timing or order of operations can lead to unpredictable results or security vulnerabilities. Preventing race conditions requires careful design and the use of appropriate synchronization techniques. Proper synchronization is crucial to maintaining data integrity and ensuring that multi-threaded or multi-process programs function as expected.\nFor further learning, it’s essential to study concurrency and synchronization mechanisms specific to your programming environment and continue exploring best practices to avoid race conditions in complex systems.\n","date":"3 January 2025","externalUrl":null,"permalink":"/posts/race-condition/","section":"Posts","summary":"Techniques for Exploiting Race Conditions","title":"Race Condition","type":"posts"},{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"3 January 2025","externalUrl":null,"permalink":"/tags/vulnerability-analysis/","section":"Tags","summary":"","title":"Vulnerability Analysis","type":"tags"},{"content":"","date":"1 January 2025","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":" calc # Let\u0026rsquo;s check # Check if the expression valid. There is nothing important in the above section; I will check the details in parse_expr.\nint __cdecl parse_expr(int input, _DWORD *arr) { int v3; // eax int v4; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v6; // [esp+28h] [ebp-80h] int lenNum; // [esp+2Ch] [ebp-7Ch] char *num; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] _BYTE expression[100]; // [esp+38h] [ebp-70h] BYREF unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v4 = input; v6 = 0; bzero(expression, 0x64u); // erases for ( i = 0; ; ++i ) { if ( *(char *)(i + input) - (unsigned int)\u0026#39;0\u0026#39; \u0026gt; 9 )// check in [+, -, *, /, %] or null byte \\(￣︶￣*\\)) { lenNum = i + input - v4; num = (char *)malloc(lenNum + 1); memcpy(num, v4, lenNum); num[lenNum] = 0; if ( !strcmp(num, \u0026#34;0\u0026#34;) ) { puts(\u0026#34;prevent division by zero\u0026#34;); fflush(stdout); return 0; } v9 = atoi(num); if ( v9 \u0026gt; 0 ) { v3 = (*arr)++; arr[v3 + 1] = v9; } if ( *(_BYTE *)(i + input) \u0026amp;\u0026amp; *(char *)(i + 1 + input) - (unsigned int)\u0026#39;0\u0026#39; \u0026gt; 9 )// // check if current index is not null and next index is not the num // if current index is null, continue { puts(\u0026#34;expression error!\u0026#34;); fflush(stdout); return 0; } v4 = i + 1 + input; // next num if ( expression[v6] ) { switch ( *(_BYTE *)(i + input) ) { case \u0026#39;%\u0026#39;: case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: if ( expression[v6] != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; expression[v6] != \u0026#39;-\u0026#39; )// check in [%, *, /] -\u0026gt; calculate immediately goto LABEL_14; expression[++v6] = *(_BYTE *)(i + input); break; case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: LABEL_14: eval(arr, expression[v6]); // calculate the right first and replace with new sign expression[v6] = *(_BYTE *)(i + input); break; default: // it checks byte \u0026#34;\\n\u0026#34; ~ mean end of input eval(arr, expression[v6--]); // calculate the right first and remove this sign break; } } else { expression[v6] = *(_BYTE *)(i + input); } if ( !*(_BYTE *)(i + input) ) break; } } while ( v6 \u0026gt;= 0 ) eval(arr, expression[v6--]); return 1; } I comment in detail in some important code, so I just summarize the main note.\nThis function checks each char in input until this char is in [+, -, *, /, %] or a null byte. Why NULL byte?? The reason for this is that - (unsigned int)'0' If matched, it calls malloc and atoi to convert to a number. Especially, this saves the number of num to *arr and each num after this,arr while arr is v1[101] in the calc function. I imagine that v1[0] saves the number of num, and v1[1], v1[2],\u0026hellip;. save each number after. In the first expression, this function doesn\u0026rsquo;t call anything; it just saves the first size to expression[].\nThe next work is the same as the above-mentioned steps, but now this will calculate\nif ( expression[v6] ) { switch ( *(_BYTE *)(i + input) ) { case \u0026#39;%\u0026#39;: case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: if ( expression[v6] != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; expression[v6] != \u0026#39;-\u0026#39; )// check in [%, *, /] -\u0026gt; calculate immediately goto LABEL_14; expression[++v6] = *(_BYTE *)(i + input); break; case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: LABEL_14: eval(arr, expression[v6]); // calculate the right first and replace with new sign expression[v6] = *(_BYTE *)(i + input); break; default: // it checks byte \u0026#34;\\n\u0026#34; ~ mean end of input eval(arr, expression[v6--]); // calculate the right first and remove this sign break; } } eval only calculate two number a1[*a1 - 1] and a1[*a1] and give the result in the first number. After that, this will decrease *a1 ~ the number of num to get the index of the result and calculate later expression.\nThis rule is that calculate [*, /, %] before [+, -]. This section implement by locating the sign with higher role in the right of expression. If sign in [*, /, %], and the previous also in this, this will calculate the previous first because of the same role. Meanwhile, if sign in [*, /, %] and the previous in [+, -], this only add this sign to the right of expression. If sign in [+, -], it will calculate the right most of expression and replace the old sign. Example\n1+2*3+4 →1 →1+2*3 →1+6+4\n1+2*3*4+5 →1+2*3 →1+6*4 →1+24+5\n1*2+3+4*5 →1*2 →2+3 →5+4*5\n1*2+3+4*5+6 →1*2 →2+3 →5+4*5 →5+20+6\nOnce done, this section will calculate from the right to the left of the expression; this would be right because the sign in the later expression is only in [+, -] or the sign with the higher role in the rightmost\nwhile ( v6 \u0026gt;= 0 ) eval(arr, expression[v6--]); Exploitation # Hmm, do I miss something?\nI just think that this should only handle (check in loop) with sign instead of both sign and number.\nIf it gets two numbers in v1 to calculate, is it possible to input only one number and trigger something?\nIs this use of v1[0] as a count and taking it as the index to calculate while num is just in the next location secure?\nIf I don\u0026rsquo;t input any number before signing in the first expression.\nif ( sign == \u0026#39;+\u0026#39; ) { a1[*a1 - 1] += a1[*a1]; } if ( parse_expr(input, v1) ) // calculate expression { printf(\u0026#34;%d\\n\u0026#34;, v1[v1[0]]); fflush(stdout); } AAR # -5333956 ~ 0xffae9c3c\ncount = 1\n→ a1[count - 1] += a1[count] (a1[0] ~ count ; a1[1] = 400)\n→ a1[0] = 1 + a1[1] = 1 + 400 = 401\n→ count = 401\nAAW # count = 1\n→ a1[count - 1] += a1[count] (a1[0] ~ count ; a1[1] = 400)\n→ a1[0] = 1 + a1[1] = 1 + 400 = 401\n→ count = 401\n→ a1[count - 1] += a1[count] (a1[0] ~ count ; a1[1] = 400)\n→ a1[400] += a1[401]\na1[401] = 1, the reason for this is that\nif ( v9 \u0026gt; 0 ) { v3 = (*arr)++; arr[v3 + 1] = v9; } Note # The other sign has the same logic bug, so I just use it to leak, write the payload, and execute this.\nPayload # solve.py\nSecrect Garden # Let\u0026rsquo;s check # raise # int raise() { _QWORD *v0; // rbx void *v1; // rbp _QWORD *v2; // rcx unsigned int v3; // edx _DWORD size[9]; // [rsp+4h] [rbp-24h] BYREF *(_QWORD *)\u0026amp;size[1] = __readfsqword(0x28u); size[0] = 0; if ( count_flower \u0026gt; 0x63u ) return puts(\u0026#34;The garden is overflow\u0026#34;); v0 = malloc(0x28uLL); *v0 = 0LL; v0[1] = 0LL; // name v0[2] = 0LL; // color v0[3] = 0LL; v0[4] = 0LL; __printf_chk(1LL, \u0026#34;Length of the name :\u0026#34;); if ( (unsigned int)__isoc99_scanf(\u0026#34;%u\u0026#34;, size) == -1 ) exit(-1); v1 = malloc(size[0]); if ( !v1 ) { puts(\u0026#34;Alloca error !!\u0026#34;); exit(-1); } __printf_chk(1LL, \u0026#34;The name of flower :\u0026#34;); read(0, v1, size[0]); v0[1] = v1; __printf_chk(1LL, \u0026#34;The color of the flower :\u0026#34;); __isoc99_scanf(\u0026#34;%23s\u0026#34;, v0 + 2); *(_DWORD *)v0 = 1; // mark it grow if ( garden[0] ) { v2 = \u0026amp;garden[1]; v3 = 1; while ( *v2 ) { ++v3; ++v2; if ( v3 == 100 ) goto Add; } } else { v3 = 0; } garden[v3] = v0; Add: ++count_flower; return puts(\u0026#34;Successful !\u0026#34;); } raise() use malloc to allocate for v0 with the size of 0x28, make sure all element in v0 is zero. Then, malloc to allocate for v1 with the size which I input, I will enter the name of flower with the respectively size. -\u0026gt; v0[1] = v1 -\u0026gt; v0[1] is the pointer to v1. Afterwards, raise() requires to input the color of the flower with the size: 23(make sure \u0026lt; 3 bytes), and store in v0[2], and -\u0026gt;*(_DWORD *)v0 = 1; Finally, it stores v0 to garden make sure the size of garden \u0026lt;= 100 I think about the struct like this\nstruct Flower{ int used; #set when raise successfully char *name_flower; #input the size and input the name char color_flower[24]; #nothing special, except for the input } Then, the program will store a pointer to this struct in garden.\nvisit # int visit() { __int64 v0; // rbx __int64 v1; // rax v0 = 0LL; if ( count_flower ) { do { v1 = garden[v0]; if ( v1 \u0026amp;\u0026amp; *(_DWORD *)v1 ) { __printf_chk(1LL, \u0026#34;Name of the flower[%u] :%s\\n\u0026#34;, v0, *(const char **)(v1 + 8)); LODWORD(v1) = __printf_chk(1LL, \u0026#34;Color of the flower[%u] :%s\\n\u0026#34;, v0, (const char *)(garden[v0] + 16LL)); } ++v0; } while ( v0 != 100 ); } else { LODWORD(v1) = puts(\u0026#34;No flower in the garden !\u0026#34;); } return v1; } It is simple to print all the flowers in the garden with the condition that v1 \u0026amp;\u0026amp; *(_DWORD *)v1, which also means v1 is the valid pointer (not null) and used in struct flower is set.\nremove # int remove() { _DWORD *v1; // rax unsigned int index; // [rsp+4h] [rbp-14h] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-10h] v3 = __readfsqword(0x28u); if ( !count_flower ) return puts(\u0026#34;No flower in the garden\u0026#34;); __printf_chk(1LL, \u0026#34;Which flower do you want to remove from the garden:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;index); if ( index \u0026lt;= 0x63 \u0026amp;\u0026amp; (v1 = (_DWORD *)garden[index]) != 0LL ) { *v1 = 0; // mark Flower = 0, but this function doesn\u0026#39;t check it free(*(void **)(garden[index] + 8LL)); // don\u0026#39;t free Flower, only free name of Flower return puts(\u0026#34;Successful\u0026#34;); } else { puts(\u0026#34;Invalid choice\u0026#34;); return 0; } } This function takes input(index) from user and check index \u0026lt;= 0x63 \u0026amp;\u0026amp; (v1 = (_DWORD *)garden[index]) != 0LL , then free this pointer to flower.\nclean # unsigned __int64 clean() { _QWORD *v0; // rbx _DWORD *v1; // rdi unsigned __int64 v3; // [rsp+8h] [rbp-20h] v3 = __readfsqword(0x28u); v0 = garden; do { v1 = (_DWORD *)*v0; if ( *v0 \u0026amp;\u0026amp; !*v1 ) { free(v1); // Also free Flower *v0 = 0LL; --count_flower; } ++v0; } while ( v0 != \u0026amp;garden[100] ); puts(\u0026#34;Done!\u0026#34;); return __readfsqword(0x28u) ^ v3; } Loop all flower in the garden(from 0 to 100), check condition: *v0 \u0026amp;\u0026amp; !*v1 exit # leave the program\nExploitation # if ( index \u0026lt;= 0x63 \u0026amp;\u0026amp; (v1 = (_DWORD *)garden[index]) != 0LL ) { *v1 = 0; // mark Flower = 0, but this function doesn\u0026#39;t check it free(*(void **)(garden[index] + 8LL)); // don\u0026#39;t free Flower, only free name of Flower return puts(\u0026#34;Successful\u0026#34;); } free: not set ptr to null and check used to 0. -\u0026gt; double free -\u0026gt; arbitrary write primitives\nAnd free THE CHUNK STORE THE NAME OF THE FLOWER, NOT THE FLOWER.\nLeak libc # Notice that: in the raise() function, the program will malloc 0x28 (the chunk will have a size of 0x30) and I have one more time to request malloc with the size I input(for name of the flower). Target: unsortedbin + remainder. Example\nI request 0x100 size for name (0x110 size for chunk) twice; the second is to ensure that the chunk will not consolidate with the top chunk. Then, free the first chunk Request 0xd8 size for name(0xe0 size for chunk) The reason: 0x30 + 0xe0 = 0x110 First, the unsorted will take 0x30 in unsortedbin to request for the struct flower, and the request for the name in the second (0xe0) will allocate for the remain chunk. Write the name with length 8 to leak the address of unsortedbin when call printf() The result # Before free I don\u0026rsquo;t know exactly what the chunk with size of 0x1011 is, but it is not important, so I will pass it. After request to trigger\nThe first request for the struct flower. Next, request for the name of the flower.\nThe next time I call visit(), it will leak the address of unsortedbin-\u0026gt;leaklibc.\nFastbin dup to trigger call system(\u0026quot;/bin/sh\u0026quot;): onegadget.\nFirst, I try to overwrite the malloc_hook with one gadet. Unless it fails, I will find other ways. Fortunately, it works.\nPayload # solve.py\n","date":"1 January 2025","externalUrl":null,"permalink":"/posts/pwnable.tw/","section":"Posts","summary":"","title":"pwnable.tw","type":"posts"},{"content":"","date":"1 January 2025","externalUrl":null,"permalink":"/tags/write-up/","section":"Tags","summary":"","title":"Write-Up","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]